// simulator.cpp

#include <arpa/inet.h>   // inet_addr
#include <sys/types.h>
#include <iostream>
#include <vector>
#include <cmath>
#include <thread>
#include <mutex>
#include <atomic>
#include <chrono>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <iomanip>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <cstring>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

// ============================================================================
// CONFIGURATION & CONSTANTS
// ============================================================================
const int WINDOW_SIZE = 800;
const int MARGIN = 60;
const double WORLD_MIN = -1.8;
const double WORLD_MAX = 1.8;
const int NUM_POINTS = 150;
const int SERVER_PORT = 8765;
const int RENDERER_PORT = 8766; // TCP port for external 3D renderer (simulator -> renderer)

// --------------------------- dynamic world bounds ---------------------------
static double WORLD_MIN_X = -1.0;
static double WORLD_MAX_X =  1.0;
static double WORLD_MIN_Y = -1.0;
static double WORLD_MAX_Y =  1.0;

// ---------------------------------------------------------------------------
// vertical stacking for 3D output (z-offset)
static double globalLayerOffset = 0.0;      // persistent z offset between sends
static constexpr double DEFAULT_LAYER_HEIGHT = 0.01; // adjust to desired layer height

// ============================================================================
// MATH UTILITIES
// ============================================================================
struct Point2D {
    double x, y;
    Point2D() : x(0), y(0) {}
    Point2D(double x_, double y_) : x(x_), y(y_) {}
};

struct Point3D {
    double x, y, z;
    Point3D() : x(0), y(0), z(0) {}
    Point3D(double X, double Y, double Z) : x(X), y(Y), z(Z) {}
};

// Forward declarations for functions defined later
std::vector<std::vector<Point3D>> generateMorphRings(
    const std::vector<Point2D>& fromRing, const std::vector<Point2D>& toRef,
    int revolutions, double heightPerRevolution);

std::vector<Point3D> flattenRingsToPath(const std::vector<std::vector<Point3D>>& rings);

// We provide two overloads for writing G-code:
//  - writeGCodeForPath(path, std::ofstream&)  -> writes into an open ofstream
//  - writeGCodeForPath(path, filename)        -> convenience wrapper creating an ofstream
void writeGCodeForPath(const std::vector<Point3D>& path, std::ofstream& ofs) {
    if (!ofs.is_open()) {
        std::cerr << "[GCODE] Provided ofstream is not open\n";
        return;
    }
    ofs << "; Generated by ILC simulator\n";
    ofs << "G21 ; mm\nG90 ; absolute\nG92 E0\n";
    double e = 0.0;
    ofs << "G1 F1200\n";
    if (!path.empty()) {
        ofs << "G0 X" << path[0].x << " Y" << path[0].y << " Z" << path[0].z << "\n";
    }
    for (size_t i = 1; i < path.size(); ++i) {
        double dx = path[i].x - path[i-1].x;
        double dy = path[i].y - path[i-1].y;
        double dz = path[i].z - path[i-1].z;
        double dist = std::sqrt(dx*dx + dy*dy + dz*dz);
        e += dist * 0.02; // default extrusion factor
        ofs << "G1 X" << path[i].x << " Y" << path[i].y << " Z" << path[i].z << " E" << e << "\n";
    }
    ofs << "M104 S0\nM140 S0\nM84\n";
    ofs.flush();
    std::cout << "[GCODE] Appended " << path.size() << " moves to stream\n";
}

void writeGCodeForPath(const std::vector<Point3D>& path, const std::string& filename,
                       double feedrate = 1500.0, double extrusionFactor = 0.02) {
    // wrapper: create file and call the ofstream version
    std::ofstream ofs(filename, std::ios::out);
    if (!ofs.is_open()) {
        std::cerr << "[GCODE] Failed to open " << filename << std::endl;
        return;
    }

    // write header and moves similar to the ofstream overload, but using parameters
    ofs << "; Generated by ILC simulator\n";
    ofs << "G21 ; mm\nG90 ; absolute\nG92 E0\n";
    double e = 0.0;
    ofs << "G1 F" << feedrate << "\n";
    if (!path.empty()) {
        ofs << "G0 X" << path[0].x << " Y" << path[0].y << " Z" << path[0].z << "\n";
    }
    for (size_t i = 1; i < path.size(); ++i) {
        double dx = path[i].x - path[i-1].x;
        double dy = path[i].y - path[i-1].y;
        double dz = path[i].z - path[i-1].z;
        double dist = std::sqrt(dx*dx + dy*dy + dz*dz);
        e += dist * extrusionFactor;
        ofs << "G1 X" << path[i].x << " Y" << path[i].y << " Z" << path[i].z << " E" << e << "\n";
    }
    ofs << "M104 S0\nM140 S0\nM84\n";
    ofs.close();
    std::cout << "[GCODE] Wrote " << path.size() << " moves to " << filename << std::endl;
}

inline double distance(const Point2D& a, const Point2D& b) {
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return std::sqrt(dx*dx + dy*dy);
}

// Convert a 2D world coordinate to screen coordinate using dynamic bounds
inline Point2D worldToScreen(double x, double y, int width, int height) {
    double nx = (x - WORLD_MIN_X) / (WORLD_MAX_X - WORLD_MIN_X);
    double ny = (y - WORLD_MIN_Y) / (WORLD_MAX_Y - WORLD_MIN_Y);
    return Point2D(
        MARGIN + nx * (width - 2 * MARGIN),
        MARGIN + (1 - ny) * (height - 2 * MARGIN)
    );
}

// Convenience wrappers for compatibility with old code
inline int worldToScreenX(double x, int width) {
    return static_cast<int>(MARGIN + (x - WORLD_MIN_X) / (WORLD_MAX_X - WORLD_MIN_X) * (width - 2 * MARGIN));
}

inline int worldToScreenY(double y, int height) {
    return static_cast<int>(MARGIN + (1 - (y - WORLD_MIN_Y) / (WORLD_MAX_Y - WORLD_MIN_Y)) * (height - 2 * MARGIN));
}

// ============================================================================
// SHAPE GENERATOR
// ============================================================================
class ShapeGenerator {
public:
    static std::vector<Point2D> generateCircle(int numPoints, double radius = 1.0) {
        std::vector<Point2D> points;
        for (int i = 0; i < numPoints; i++) {
            double theta = (2.0 * M_PI * i) / numPoints;
            points.push_back(Point2D(radius * std::cos(theta), radius * std::sin(theta)));
        }
        return points;
    }

    static std::vector<Point2D> generateEllipse(int numPoints, double a = 1.2, double b = 0.7) {
        std::vector<Point2D> points;
        for (int i = 0; i < numPoints; i++) {
            double theta = (2.0 * M_PI * i) / numPoints;
            points.push_back(Point2D(a * std::cos(theta), b * std::sin(theta)));
        }
        return points;
    }

    static std::vector<Point2D> generateSquare(int numPoints, double side = 1.6) {
        std::vector<Point2D> points;
        int pointsPerSide = numPoints / 4;
        double half = side / 2.0;

        for (int i = 0; i < pointsPerSide; i++) {
            double t = (double)i / pointsPerSide;
            points.push_back(Point2D(-half + side * t, -half));
        }
        for (int i = 0; i < pointsPerSide; i++) {
            double t = (double)i / pointsPerSide;
            points.push_back(Point2D(half, -half + side * t));
        }
        for (int i = 0; i < pointsPerSide; i++) {
            double t = (double)i / pointsPerSide;
            points.push_back(Point2D(half - side * t, half));
        }
        for (int i = 0; i < pointsPerSide; i++) {
            double t = (double)i / pointsPerSide;
            points.push_back(Point2D(-half, half - side * t));
        }

        while (points.size() < (size_t)numPoints) {
            points.push_back(points.back());
        }
        points.resize(numPoints);
        return points;
    }

    static std::vector<Point2D> generateStar(int numPoints, double outerRadius = 1.0, double innerRadius = 0.4) {
        std::vector<Point2D> points;
        int peaks = 5;
        int pointsPerPeak = numPoints / (peaks * 2);

        for (int i = 0; i < peaks * 2; i++) {
            double angle = (M_PI * i) / peaks;
            double radius = (i % 2 == 0) ? outerRadius : innerRadius;

            for (int j = 0; j < pointsPerPeak; j++) {
                double t = (double)j / pointsPerPeak;
                double nextAngle = (M_PI * (i + 1)) / peaks;
                double nextRadius = ((i + 1) % 2 == 0) ? outerRadius : innerRadius;

                double r = radius + t * (nextRadius - radius);
                double a = angle + t * (nextAngle - angle);
                points.push_back(Point2D(r * std::cos(a), r * std::sin(a)));
            }
        }
        points.resize(numPoints);
        return points;
    }

    // ----------------------------- geometry helpers -----------------------------
    static Point2D computeCentroid(const std::vector<Point2D>& poly) {
        double cx = 0.0, cy = 0.0;
        double area = 0.0;
        size_t n = poly.size();
        if (n == 0) return Point2D(0,0);
        for (size_t i = 0; i < n; ++i) {
            size_t j = (i + 1) % n;
            double a = poly[i].x * poly[j].y - poly[j].x * poly[i].y;
            area += a;
            cx += (poly[i].x + poly[j].x) * a;
            cy += (poly[i].y + poly[j].y) * a;
        }
        if (std::abs(area) < 1e-9) {
            cx = 0; cy = 0;
            for (auto &p: poly) { cx += p.x; cy += p.y; }
            return Point2D(cx / n, cy / n);
        }
        area *= 0.5;
        cx /= (6.0 * area);
        cy /= (6.0 * area);
        return Point2D(cx, cy);
    }

    static std::vector<Point2D> scaleShapeAroundCentroid(const std::vector<Point2D>& shape, double scale) {
        Point2D c = computeCentroid(shape);
        std::vector<Point2D> out; out.reserve(shape.size());
        for (auto &p : shape) {
            out.emplace_back(c.x + (p.x - c.x) * scale, c.y + (p.y - c.y) * scale);
        }
        return out;
    }

    // --------------------------- dynamic bounds update ---------------------------

    // New: smoothly morph one closed shape into another
    static std::vector<Point2D> morphShapes(
        const std::vector<Point2D>& fromShape,
        const std::vector<Point2D>& toShape,
        double t // 0 = fromShape, 1 = toShape
    ) {
        std::vector<Point2D> morphed;
        size_t n = std::min(fromShape.size(), toShape.size());
        morphed.reserve(n);
        for (size_t i = 0; i < n; i++) {
            Point2D p1 = fromShape[i];
            Point2D p2 = toShape[i];
            Point2D p((1 - t) * p1.x + t * p2.x,
                      (1 - t) * p1.y + t * p2.y);
            morphed.push_back(p);
        }
        return morphed;
    }
};

// flatten rings -> single path point list (in order)
std::vector<Point3D> flattenRingsToPath(const std::vector<std::vector<Point3D>>& rings) {
    std::vector<Point3D> path;
    for (const auto &ring : rings) {
        for (const auto &p : ring) path.push_back(p);
    }
    return path;
}

static void updateWorldBounds(const std::vector<Point2D>& shape) {
    if (shape.empty()) return;
    double minx = 1e9, maxx = -1e9, miny = 1e9, maxy = -1e9;
    for (const auto& p : shape) {
        minx = std::min(minx, p.x);
        maxx = std::max(maxx, p.x);
        miny = std::min(miny, p.y);
        maxy = std::max(maxy, p.y);
    }
    double padx = (maxx - minx) * 0.1 + 0.01; // 10% padding
    double paddy = (maxy - miny) * 0.1 + 0.01;
    WORLD_MIN_X = minx - padx;
    WORLD_MAX_X = maxx + padx;
    WORLD_MIN_Y = miny - paddy;
    WORLD_MAX_Y = maxy + paddy;

    std::cout << "[2D View] Updated world bounds: X["
              << WORLD_MIN_X << ", " << WORLD_MAX_X
              << "] Y[" << WORLD_MIN_Y << ", " << WORLD_MAX_Y << "]\n";
}

static double zoom2DFactor = 1.0;

// Apply 2D zoom by scaling WORLD_MIN/MAX around the centroid of a shape
static void applyZoom2D(double factor, const std::vector<Point2D> *referenceShape = nullptr) {
    // factor > 1 => zoom in, factor < 1 => zoom out (multiplicative)
    if (factor <= 0) return;
    zoom2DFactor *= factor;
    // clamp zoom factor to avoid degenerate extremes
    if (zoom2DFactor < 0.2) zoom2DFactor = 0.2;
    if (zoom2DFactor > 10.0) zoom2DFactor = 10.0;

    // compute centroid to scale around; prefer provided reference, otherwise use WORLD mid
    Point2D c;
    if (referenceShape && !referenceShape->empty()) {
        c = ShapeGenerator::computeCentroid(*referenceShape);
    } else {
        c.x = 0.5 * (WORLD_MIN_X + WORLD_MAX_X);
        c.y = 0.5 * (WORLD_MIN_Y + WORLD_MAX_Y);
    }

    double halfW = 0.5 * (WORLD_MAX_X - WORLD_MIN_X);
    double halfH = 0.5 * (WORLD_MAX_Y - WORLD_MIN_Y);

    halfW /= factor; // if factor > 1, halfW gets smaller -> zoom in
    halfH /= factor;

    WORLD_MIN_X = c.x - halfW;
    WORLD_MAX_X = c.x + halfW;
    WORLD_MIN_Y = c.y - halfH;
    WORLD_MAX_Y = c.y + halfH;
}

// Reset 2D zoom to fit provided shape
static void resetZoom2DToShape(const std::vector<Point2D>& shape) {
    zoom2DFactor = 1.0;
    updateWorldBounds(shape);
}

// ============================================================================
// ILC CONTROLLER
// ============================================================================
class ILCController {
private:
    int numPoints;
    double learningRate;
    double systemErrorLevel;
    int iteration;
    bool enableNoise;
    double smoothingAlpha;  // Smoothing factor for gradual correction

    std::vector<Point2D> reference;
    std::vector<Point3D> corrections;
    std::vector<Point2D> currentTrajectory;
    std::vector<Point2D> lastErrors;
    std::vector<std::vector<Point2D>> completedPaths;

    double lastRMSError;

    // dome adaptation control
    bool domeActive = false;
    std::vector<Point2D> domeTarget;   // target cross-section to converge to
    double domeEpsilon = 1e-3;         // stop when max point distance < this
    double domeMorphStep = 0.1;        // how aggressively to morph reference toward domeTarget per iteration

    // --- Morph transition support (gradual transition when new shape is requested)
    bool morphActive = false;
    std::vector<Point2D> morphTarget;
    double morphProgress = 0.0;   // 0..1
    double morphStep = 0.08;      // progress increment per iteration (tuneable; smaller = smoother)

    // *** CHANGED: parameters controlling morph-as-error behavior
    double morphVirtualCorrectionFactor = 0.5; // how much of the morph is applied as virtual error to corrections
    double morphSmoothingMultiplier = 1.0;     // multiply smoothingAlpha for morph-driven corrections

public:
    ILCController(int nPts, double lr)
        : numPoints(nPts), learningRate(lr), systemErrorLevel(0.0),
          iteration(0), enableNoise(false), smoothingAlpha(0.3), lastRMSError(0.0) {
        corrections.assign(numPoints, Point3D(0, 0, 0));
        reference = ShapeGenerator::generateCircle(numPoints);
    }

    void setReference(const std::vector<Point2D>& ref) {
        if (ref.empty()) return;
        reference = ref;
        updateWorldBounds(ref);
        reference.resize(numPoints);
        std::cout << "[ILC] Reference updated (adaptive tracking continues)\n";
    }

    // Start a gradual morph toward newShape (runs over several completeIteration() calls)
    void startMorphTo(const std::vector<Point2D>& newShape, double step = 0.08) {
        if (newShape.empty()) return;
        morphTarget = newShape;
        if (morphTarget.size() != (size_t)numPoints) morphTarget.resize(numPoints, morphTarget.back());
        morphProgress = 0.0;
        morphStep = std::max(0.005, std::min(0.3, step));
        morphActive = true;
        std::cout << "[ILC] startMorphTo called (step=" << morphStep << ")\n";
    }


    // Start dome convergence: target is a full shape (same size as reference)
    void startDomeToTarget(const std::vector<Point2D>& target) {
        if (target.empty()) return;
        domeTarget = target;
        // ensure domeTarget has same point count as reference
        if (domeTarget.size() != (size_t)numPoints) domeTarget.resize(numPoints, domeTarget.back());
        domeActive = true;
        std::cout << "[ILC] Dome mode started (adaptive convergence)\n";
    }

    void stopDome() {
        domeActive = false;
        std::cout << "[ILC] Dome mode stopped\n";
    }

    bool isDomeActive() const { return domeActive; }

    // Create a 'zero-dimension' target (collapse to centroid)
    std::vector<Point2D> makeCollapsedTarget() const {
        Point2D c = ShapeGenerator::computeCentroid(reference);
        std::vector<Point2D> tgt(numPoints, c);
        return tgt;
    }

    // New: gradually transform reference shape into a new one over multiple iterations
    void morphReferenceTo(const std::vector<Point2D>& newShape, double progress) {
        // Clamp progress 0–1
        progress = std::max(0.0, std::min(1.0, progress));
        auto morphed = ShapeGenerator::morphShapes(reference, newShape, progress);
        reference = morphed;
    }

    // New: build dome layers by reducing radius each iteration
    void buildDomeLayered(double initialRadius, double finalRadius, int totalLayers) {
        double step = (initialRadius - finalRadius) / std::max(1, totalLayers - 1);
        completedPaths.clear();

        for (int i = 0; i < totalLayers; i++) {
            double currentRadius = initialRadius - i * step;
            auto layer = ShapeGenerator::generateCircle(numPoints, currentRadius);
            completedPaths.push_back(layer);
        }
        // After dome layers are generated, set the last layer as new reference
        if (!completedPaths.empty()) {
            reference = completedPaths.back();
        }
        std::cout << "[ILC] Dome layers generated (" << totalLayers << " layers)\n";
    }

    Point2D plantModel(const Point2D& command, int pathIndex) {
        Point2D output = command;

        if (systemErrorLevel > 0) {
            double theta = (2.0 * M_PI * pathIndex) / numPoints;

            // Multi-harmonic systematic error
            double radialError = systemErrorLevel * (
                0.25 * std::sin(3 * theta) +
                0.15 * std::sin(5 * theta) +
                0.10 * std::cos(2 * theta)
            );

            double phaseError = systemErrorLevel * (0.18 + 0.02 * std::sin(0.5 * theta + iteration));
            double contractionError = systemErrorLevel * (0.12 + 0.03 * std::cos(1.5 * theta));

            double radius = std::sqrt(output.x * output.x + output.y * output.y);
            double angle = std::atan2(output.y, output.x);

            double newRadius = radius * (1 - contractionError) + radialError;
            double newAngle = angle + phaseError;

            output.x = newRadius * std::cos(newAngle);
            output.y = newRadius * std::sin(newAngle);

            // Optional noise
            if (enableNoise) {
                double noiseAmp = systemErrorLevel * 0.04;
                output.x += (rand() / (double)RAND_MAX - 0.5) * noiseAmp;
                output.y += (rand() / (double)RAND_MAX - 0.5) * noiseAmp;
            }
        }

        return output;
    }

    // *** CHANGED: compute realtime error each time we sample a point (helps shape-change RMS)
    void updateRealtimeError() {
        if (currentTrajectory.empty()) return;
        double total = 0.0;
        size_t n = currentTrajectory.size();
        for (size_t i = 0; i < n && i < reference.size(); ++i) {
            double dx = reference[i].x - currentTrajectory[i].x;
            double dy = reference[i].y - currentTrajectory[i].y;
            total += dx*dx + dy*dy;
        }
        lastRMSError = std::sqrt(total / std::max<size_t>(1, n));
    }

    Point2D getCurrentPosition(int pathIndex) {
        if (pathIndex >= numPoints) pathIndex = numPoints - 1;

        Point2D refPoint = reference[pathIndex];
        Point2D correction(corrections[pathIndex].x, corrections[pathIndex].y);

        // Apply full correction (no smoothing here - that's for the update law)
        Point2D command;
        command.x = refPoint.x + correction.x;
        command.y = refPoint.y + correction.y;

        Point2D actual = plantModel(command, pathIndex);

        if ((int)currentTrajectory.size() <= pathIndex) {
            currentTrajectory.push_back(actual);
        } else {
            currentTrajectory[pathIndex] = actual;
        }

        // update realtime RMS/error based on observed currentTrajectory
        updateRealtimeError(); // *** CHANGED: keeps lastRMSError updated continuously

        return actual;
    }

    double completeIteration() {
        if (currentTrajectory.size() < (size_t)numPoints) return lastRMSError;

        std::cout << "[ILC] Completing iteration " << iteration << std::endl;

        std::vector<Point2D> trackingErrors;
        double totalError = 0;

        // Standard ILC: Calculate error from REFERENCE, not previous iteration
        for (int i = 0; i < numPoints; i++) {
            Point2D refPt = reference[i];
            Point2D actualPt = currentTrajectory[i];

            // Direct error calculation: e_k(i) = reference(i) - actual_k(i)
            Point2D error;
            error.x = refPt.x - actualPt.x;
            error.y = refPt.y - actualPt.y;
            trackingErrors.push_back(error);

            totalError += error.x * error.x + error.y * error.y;
        }

        double rmsError = std::sqrt(totalError / numPoints);
        lastRMSError = rmsError;

        // Standard ILC update with smoothing for gradual correction
        for (int i = 0; i < numPoints && i < (int)trackingErrors.size(); i++) {
            double proposedDeltaX = learningRate * trackingErrors[i].x;
            double proposedDeltaY = learningRate * trackingErrors[i].y;

            corrections[i].x += smoothingAlpha * proposedDeltaX;
            corrections[i].y += smoothingAlpha * proposedDeltaY;
            corrections[i].z += smoothingAlpha * 0.0; // placeholder for Z correction (optional)

            double correctionMag = std::sqrt(corrections[i].x * corrections[i].x +
                                            corrections[i].y * corrections[i].y);
            if (correctionMag > 1.0) {
                corrections[i].x = (corrections[i].x / correctionMag) * 1.0;
                corrections[i].y = (corrections[i].y / correctionMag) * 1.0;
            }
        }

        iteration++;
        lastErrors = trackingErrors;

        // --- If morphActive, advance morphProgress and update reference gradually ---
        if (morphActive && !morphTarget.empty()) {
            morphProgress += morphStep;
            if (morphProgress >= 1.0) {
                reference = morphTarget;
                morphActive = false;
                morphProgress = 1.0;
                std::cout << "[ILC] Morph complete (reference replaced)\n";
            } else {
                // smoothstep blending for nicer ease-in/out
                double t = morphProgress;
                double s = t*t*(3 - 2*t);
                auto morphed = ShapeGenerator::morphShapes(reference, morphTarget, s);

                // *** CHANGED: treat part of the morph as a virtual error so corrections adapt similarly to error-driven updates.
                // This makes the ILC respond to shape-change similarly to how it responds to plant error (reduces jumps).
                for (int i = 0; i < numPoints; ++i) {
                    double vx = morphed[i].x - reference[i].x; // desired delta
                    double vy = morphed[i].y - reference[i].y;

                    // Virtual "error" scaled down by morphVirtualCorrectionFactor
                    double proposedDeltaX = learningRate * (vx * morphVirtualCorrectionFactor);
                    double proposedDeltaY = learningRate * (vy * morphVirtualCorrectionFactor);

                    corrections[i].x += smoothingAlpha * morphSmoothingMultiplier * proposedDeltaX;
                    corrections[i].y += smoothingAlpha * morphSmoothingMultiplier * proposedDeltaY;

                    double correctionMag = std::sqrt(corrections[i].x * corrections[i].x +
                                                    corrections[i].y * corrections[i].y);
                    if (correctionMag > 1.0) {
                        corrections[i].x = (corrections[i].x / correctionMag) * 1.0;
                        corrections[i].y = (corrections[i].y / correctionMag) * 1.0;
                    }
                }

                // finally update the reference gradually (so the visual reference moves smoothly)
                reference = morphed;
                // keep bounds updated for the visualizer
                updateWorldBounds(reference);
                std::cout << "[ILC] Morph progress: " << std::fixed << std::setprecision(3) << morphProgress << "\n";
            }
        }

        // --- If dome mode is active, morph the reference gradually toward domeTarget ---
        if (domeActive && !domeTarget.empty()) {
            // compute max distance to target
            double maxDist = 0.0;
            for (int i = 0; i < numPoints; ++i) {
                double dx = domeTarget[i].x - reference[i].x;
                double dy = domeTarget[i].y - reference[i].y;
                double d = std::sqrt(dx*dx + dy*dy);
                maxDist = std::max(maxDist, d);
            }

            if (maxDist <= domeEpsilon) {
                domeActive = false;
                std::cout << "[ILC] Dome target reached (maxDist=" << maxDist << ") — dome mode off\n";
            } else {
                // morph amount scales with learningRate and last RMS error so it slows if converged
                double step = std::min(0.5, std::max(0.02, learningRate * smoothingAlpha));
                // move reference points toward domeTarget by a smoothstep of step
                for (int i = 0; i < numPoints; ++i) {
                    reference[i].x = reference[i].x + step * (domeTarget[i].x - reference[i].x);
                    reference[i].y = reference[i].y + step * (domeTarget[i].y - reference[i].y);
                }
                // update bounds for visualization
                updateWorldBounds(reference);
                std::cout << "[ILC] Dome morph step applied (maxDist=" << maxDist << ", step=" << step << ")\n";
            }
        }

        std::cout << "[ILC] Iteration " << iteration-1 << " RMS Error: " << rmsError << std::endl;

        // Store completed path
        completedPaths.push_back(currentTrajectory);
        // keep a larger history so renderer can display many layers
        if (completedPaths.size() > 200) {
            completedPaths.erase(completedPaths.begin());
        }

        currentTrajectory.clear();

        if (iteration > 1) {
            std::cout << "[ILC] Adapting to possibly new reference — RMS Error now: "
                      << lastRMSError << std::endl;
        }
        return rmsError;
    }

    void induceError(double level) {
        systemErrorLevel = level;
        std::cout << "[ILC] System error set to " << (level * 100) << "%" << std::endl;
    }

    void setLearningRate(double lr) {
        learningRate = lr;
        std::cout << "[ILC] Learning rate set to " << lr << std::endl;
    }

    void setSmoothingFactor(double alpha) {
        smoothingAlpha = std::max(0.1, std::min(1.0, alpha));
        std::cout << "[ILC] Smoothing factor set to " << smoothingAlpha << std::endl;
        std::cout << "      (Controls rate of correction update - higher = faster learning)" << std::endl;
    }

    void setNoise(bool enabled) {
        enableNoise = enabled;
        std::cout << "[ILC] Noise " << (enabled ? "enabled" : "disabled") << std::endl;
    }

    void reset() {
        corrections.assign(numPoints, Point3D(0, 0, 0));
        currentTrajectory.clear();
        lastErrors.clear();
        completedPaths.clear();
        iteration = 0;
        systemErrorLevel = 0;
        lastRMSError = 0;
        std::cout << "[ILC] Reset complete" << std::endl;
    }

    // Getters
    const std::vector<Point2D>& getReference() const { return reference; }
    const std::vector<Point2D>& getCurrentTrajectory() const { return currentTrajectory; }
    const std::vector<std::vector<Point2D>>& getCompletedPaths() const { return completedPaths; }
    const std::vector<Point2D>& getLastErrors() const { return lastErrors; }
    int getIteration() const { return iteration; }
    double getRMSError() const { return lastRMSError; }
    double getErrorLevel() const { return systemErrorLevel; }
    bool getNoiseEnabled() const { return enableNoise; }
    const std::vector<Point2D>& getBaseCrossSection() const {
        return reference;
    }

    double getAvgCorrection() const {
        double sum = 0;
        for (const auto& c : corrections) {
            sum += std::sqrt(c.x*c.x + c.y*c.y);
        }
        return sum / numPoints;
    }
};

// ============================================================================
// X11 VISUALIZER (double-buffered via Pixmap)
// ============================================================================
class X11Visualizer {
public:
    Display* display;
    Window window;
private:
    GC gc;
    int screen;
    XColor colors[10];
    Pixmap backBuffer;
    int bufW, bufH;
public:
    X11Visualizer() : backBuffer(None), bufW(WINDOW_SIZE), bufH(WINDOW_SIZE) {
        display = XOpenDisplay(nullptr);
        if (!display) {
            std::cerr << "Cannot open X display" << std::endl;
            exit(1);
        }

        screen = DefaultScreen(display);
        window = XCreateSimpleWindow(display, RootWindow(display, screen),
                                     10, 10, WINDOW_SIZE, WINDOW_SIZE, 1,
                                     BlackPixel(display, screen),
                                     WhitePixel(display, screen));

        // accept mouse/buttons for zoom/pan if needed
        XSelectInput(display, window,
             ExposureMask | KeyPressMask | ButtonPressMask | ButtonReleaseMask | PointerMotionMask);

        XMapWindow(display, window);
        XStoreName(display, window, "ILC Real-Time Tracker");

        gc = XCreateGC(display, window, 0, nullptr);

        // Initialize colors (now simple, pleasant palette)
        Colormap colormap = DefaultColormap(display, screen);
        XParseColor(display, colormap, "#e6eef6", &colors[0]); // nice light (reference)
        // *** CHANGED: colors[1] set to blue for 2D path & robot outline
        XParseColor(display, colormap, "#2b6fb3", &colors[1]); // blue path / outline
        XParseColor(display, colormap, "#ccdff0", &colors[2]); // grid / background accents
        XParseColor(display, colormap, "#f0f0f0", &colors[3]);
        XParseColor(display, colormap, "#666666", &colors[4]);

        for (int i = 0; i < 5; i++) XAllocColor(display, colormap, &colors[i]);

        // create pixmap backbuffer sized to the window
        backBuffer = XCreatePixmap(display, window, bufW, bufH, DefaultDepth(display, screen));
    }

    ~X11Visualizer() {
        if (backBuffer != None) XFreePixmap(display, backBuffer);
        XFreeGC(display, gc);
        XDestroyWindow(display, window);
        XCloseDisplay(display);
    }

    Display* getDisplay() { return display; }

    void resizeBuffer(int w, int h) {
        if (w == bufW && h == bufH) return;
        if (backBuffer != None) XFreePixmap(display, backBuffer);
        bufW = std::max(1, w);
        bufH = std::max(1, h);
        backBuffer = XCreatePixmap(display, window, bufW, bufH, DefaultDepth(display, screen));
    }

    void clear() {
        // Fill the pixmap with window background color
        XSetForeground(display, gc, WhitePixel(display, screen));
        XFillRectangle(display, backBuffer, gc, 0, 0, bufW, bufH);
    }

    void drawGrid() {
        XSetForeground(display, gc, colors[2].pixel);
        XSetLineAttributes(display, gc, 1, LineSolid, CapButt, JoinMiter);

        double gridLines[] = {-1.5, -1.0, -0.5, 0, 0.5, 1.0, 1.5};
        for (double val : gridLines) {
            int xPos = worldToScreenX(val, bufW);
            int yPos = worldToScreenY(val, bufH);
            XDrawLine(display, backBuffer, gc, xPos, MARGIN, xPos, bufH - MARGIN);
            XDrawLine(display, backBuffer, gc, MARGIN, yPos, bufW - MARGIN, yPos);
        }
    }

    // *** CHANGED: drawPath now respects colorIdx (1=normal blue, 2=error color)
    void drawPath(const std::vector<Point2D>& path, int colorIdx, int lineWidth, bool closed = true) {
        if (path.size() < 2) return;

        // color selection: default -> colors[1] (blue); error -> colors[2] (grid tint) or adjust as needed
        unsigned long fg = colors[1].pixel;
        if (colorIdx == 2) fg = colors[2].pixel; // using colors[2] as an "error/highlight" tone
        XSetForeground(display, gc, fg);
        XSetLineAttributes(display, gc, lineWidth, LineSolid, CapRound, JoinRound);

        for (size_t i = 0; i < path.size() - 1; i++) {
            Point2D s1 = worldToScreen(path[i].x, path[i].y, bufW, bufH);
            Point2D s2 = worldToScreen(path[i+1].x, path[i+1].y, bufW, bufH);
            XDrawLine(display, backBuffer, gc, (int)s1.x, (int)s1.y, (int)s2.x, (int)s2.y);
        }

        if (closed && path.size() > 2) {
            int x1 = worldToScreenX(path.back().x, bufW);
            int y1 = worldToScreenY(path.back().y, bufH);
            int x2 = worldToScreenX(path[0].x, bufW);
            int y2 = worldToScreenY(path[0].y, bufH);
            XDrawLine(display, backBuffer, gc, x1, y1, x2, y2);
        }
    }

    void drawRobot(const Point2D& pos, int colorIdx, int radius = 10) {
        Point2D s = worldToScreen(pos.x, pos.y, bufW, bufH);
        int x = static_cast<int>(s.x);
        int y = static_cast<int>(s.y);

        // robot uses outline color (blue) — same palette as path to indicate "current position on path"
        XSetForeground(display, gc, colors[1].pixel);
        XFillArc(display, backBuffer, gc, x - radius, y - radius,
                 radius * 2, radius * 2, 0, 360 * 64);

        // White border
        XSetForeground(display, gc, WhitePixel(display, screen));
        XSetLineAttributes(display, gc, 2, LineSolid, CapButt, JoinMiter);
        XDrawArc(display, backBuffer, gc, x - radius, y - radius,
                 radius * 2, radius * 2, 0, 360 * 64);
    }

    void drawText(int x, int y, const std::string& text) {
        XSetForeground(display, gc, BlackPixel(display, screen));
        XDrawString(display, backBuffer, gc, x, y, text.c_str(), text.length());
    }

    void flush() {
        // copy pixmap buffer to window in a single operation (no flicker)
        XCopyArea(display, backBuffer, window, gc, 0, 0, bufW, bufH, 0, 0);
        XFlush(display);
    }
};

// ============================================================================
// RENDERER CLIENT (simulator -> external renderer via TCP)
// ============================================================================
class RendererClient {
private:
    int sockfd;
    std::mutex sockMutex;
    bool connected;

public:
    RendererClient() : sockfd(-1), connected(false) {}

    ~RendererClient() {
        disconnect();
    }

    bool connectToRenderer(const std::string& host = "127.0.0.1", int port = RENDERER_PORT) {
        std::lock_guard<std::mutex> lk(sockMutex);
        if (connected) return true;

        sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if (sockfd < 0) {
            std::cerr << "[RendererClient] socket() failed\n";
            return false;
        }

        struct sockaddr_in serv_addr;
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_port = htons(port);
        serv_addr.sin_addr.s_addr = inet_addr(host.c_str());

        struct timeval tv;
        tv.tv_sec = 0;
        tv.tv_usec = 200000; // 200ms
        setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, (const char*)&tv, sizeof tv);
        setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, (const char*)&tv, sizeof tv);

        if (::connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {
            close(sockfd);
            sockfd = -1;
            return false;
        }

        connected = true;
        std::cout << "[RendererClient] Connected to renderer on port " << port << std::endl;
        return true;
    }

    void disconnect() {
        std::lock_guard<std::mutex> lk(sockMutex);
        if (sockfd >= 0) {
            close(sockfd);
            sockfd = -1;
        }
        connected = false;
    }

    bool isConnected() {
        std::lock_guard<std::mutex> lk(sockMutex);
        return connected;
    }

    bool sendPath3D(const std::vector<std::vector<Point3D>>& rings) {
        std::lock_guard<std::mutex> lk(sockMutex);
        if (!connected || sockfd < 0) return false;

        size_t totalPts = 0;
        int ringSize = rings.empty() ? 0 : (int)rings[0].size();
        for (const auto &r : rings) totalPts += r.size();

        std::ostringstream header;
        header << "BEGIN_PATH " << totalPts << " " << ringSize << "\n";

        std::string footer = "END_PATH\n";

        if (send(sockfd, header.str().c_str(), header.str().size(), 0) < 0) {
            std::cerr << "[RendererClient] send() failed (header)\n";
            close(sockfd);
            sockfd = -1;
            connected = false;
            return false;
        }

        for (const auto &ring : rings) {
            for (const auto &p : ring) {
                std::ostringstream oss;
                oss << p.x << " " << p.y << " " << p.z << "\n";
                std::string msg = oss.str();
                if (send(sockfd, msg.c_str(), msg.size(), 0) < 0) {
                    std::cerr << "[RendererClient] send() failed (body)\n";
                    close(sockfd);
                    sockfd = -1;
                    connected = false;
                    return false;
                }
                // removed per-point usleep to avoid blocking main loop and to speed transfers
            }
        }


        if (send(sockfd, footer.c_str(), footer.size(), 0) < 0) {
            std::cerr << "[RendererClient] send() failed (footer)\n";
            close(sockfd);
            sockfd = -1;
            connected = false;
            return false;
        }

        return true;
    }

    bool sendPath(const std::vector<std::vector<Point2D>>& layers2d) {
        std::vector<std::vector<Point3D>> rings;
        for (const auto &l : layers2d) {
            std::vector<Point3D> ring;
            ring.reserve(l.size());
            for (const auto &p: l)
                ring.emplace_back(p.x, p.y, 0.0);
            rings.push_back(std::move(ring));
        }
        return sendPath3D(rings);
    }

    // Send a short textual command to renderer (best-effort, thread-safe)
    bool sendCommand(const std::string& cmd) {
        std::lock_guard<std::mutex> lk(sockMutex);
        if (!connected || sockfd < 0) {
            // attempt to connect once
            if (!connectToRenderer("127.0.0.1", RENDERER_PORT)) return false;
        }
        ssize_t sent = send(sockfd, cmd.c_str(), cmd.size(), 0);
        if (sent < 0) {
            std::cerr << "[RendererClient] sendCommand failed\n";
            close(sockfd);
            sockfd = -1;
            connected = false;
            return false;
        }
        return true;
    }
};

static RendererClient rendererClient;

// ============================================================================
// COMMAND SERVER (TCP Socket)
// ============================================================================
class CommandServer {
private:
    int serverFd, clientFd;
    struct sockaddr_in address;
    std::atomic<bool> running;
    std::thread serverThread;

    ILCController* ilc;
    std::atomic<bool>* isSimRunning;
    std::mutex* ilcMutex;

public:
    CommandServer(ILCController* ilcPtr, std::atomic<bool>* runFlag, std::mutex* mtx)
        : serverFd(-1), clientFd(-1), running(false), ilc(ilcPtr),
          isSimRunning(runFlag), ilcMutex(mtx) {}

    ~CommandServer() {
        stop();
    }

    void start() {
        serverFd = socket(AF_INET, SOCK_STREAM, 0);
        if (serverFd == 0) {
            std::cerr << "[SERVER] Socket creation failed" << std::endl;
            return;
        }

        int opt = 1;
        setsockopt(serverFd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt));

        address.sin_family = AF_INET;
        address.sin_addr.s_addr = INADDR_ANY;
        address.sin_port = htons(SERVER_PORT);

        if (bind(serverFd, (struct sockaddr*)&address, sizeof(address)) < 0) {
            std::cerr << "[SERVER] Bind failed" << std::endl;
            return;
        }

        if (listen(serverFd, 3) < 0) {
            std::cerr << "[SERVER] Listen failed" << std::endl;
            return;
        }

        running = true;
        serverThread = std::thread(&CommandServer::acceptLoop, this);

        std::cout << "[SERVER] Command server started on port " << SERVER_PORT << std::endl;
    }

    void stop() {
        running = false;
        if (clientFd >= 0) close(clientFd);
        if (serverFd >= 0) close(serverFd);
        if (serverThread.joinable()) serverThread.join();
    }

private:
    void acceptLoop() {
        while (running) {
            int addrlen = sizeof(address);
            clientFd = accept(serverFd, (struct sockaddr*)&address, (socklen_t*)&addrlen);

            if (clientFd < 0) continue;

            std::cout << "[SERVER] Client connected" << std::endl;
            handleClient();
            close(clientFd);
            clientFd = -1;
        }
    }

    void handleClient() {
        char buffer[1024] = {0};

        while (running) {
            memset(buffer, 0, sizeof(buffer));
            int valread = read(clientFd, buffer, 1024);

            if (valread <= 0) break;

            std::string command(buffer);
            command.erase(command.find_last_not_of(" \n\r\t") + 1);

            std::string response = processCommand(command);
            send(clientFd, response.c_str(), response.length(), 0);
        }
    }

    std::string processCommand(const std::string& cmd) {
        std::lock_guard<std::mutex> lock(*ilcMutex);

        std::istringstream iss(cmd);
        std::string action;
        iss >> action;

        if (action == "start") {
            *isSimRunning = true;
            return "OK: Simulation started\n";
        }
        else if (action == "stop") {
            *isSimRunning = false;
            return "OK: Simulation stopped\n";
        }
        else if (action == "reset") {
            ilc->reset();
            globalLayerOffset = 0.0; // reset stacking offset too

            // reset 2D zoom / world bounds to default cross-section
            resetZoom2DToShape(ilc->getBaseCrossSection());

            // best-effort: notify 3D renderer to clear view
            if (!rendererClient.isConnected()) {
                rendererClient.connectToRenderer("127.0.0.1", RENDERER_PORT);
            }
            // send a small command the renderer will understand
            rendererClient.sendCommand("RESET_VIEW\n");

            return "OK: ILC reset (3D view cleared)\n";
        }
        else if (action == "error") {
            double level;
            iss >> level;
            ilc->induceError(level);
            return "OK: Error level set to " + std::to_string(level) + "\n";
        }
        else if (action == "lr") {
            double lr;
            iss >> lr;
            ilc->setLearningRate(lr);
            return "OK: Learning rate set to " + std::to_string(lr) + "\n";
        }
        else if (action == "smooth") {
            double alpha;
            iss >> alpha;
            ilc->setSmoothingFactor(alpha);
            return "OK: Smoothing factor set to " + std::to_string(alpha) + "\n";
        }
        else if (action == "noise") {
            std::string state;
            iss >> state;
            bool enabled = (state == "on" || state == "1");
            ilc->setNoise(enabled);
            return "OK: Noise " + std::string(enabled ? "enabled" : "disabled") + "\n";
        }
        else if (action == "shape") {
            std::string shapeType;
            iss >> shapeType;

            std::vector<Point2D> newRef;
            if (shapeType == "circle") {
                double radius = 1.0;
                iss >> radius;
                newRef = ShapeGenerator::generateCircle(NUM_POINTS, radius);
            }
            else if (shapeType == "ellipse") {
                double a = 1.2, b = 0.7;
                iss >> a >> b;
                newRef = ShapeGenerator::generateEllipse(NUM_POINTS, a, b);
            }
            else if (shapeType == "square") {
                double side = 1.6;
                iss >> side;
                newRef = ShapeGenerator::generateSquare(NUM_POINTS, side);
            }
            else if (shapeType == "star") {
                double outer = 1.0, inner = 0.4;
                iss >> outer >> inner;
                newRef = ShapeGenerator::generateStar(NUM_POINTS, outer, inner);
            }
            else {
                return "ERROR: Unknown shape type\n";
            }

            // If simulation not running -> treat as default (set immediately, no morph)
            if (!(*isSimRunning)) {
                ilc->setReference(newRef);
                // also reset 2D zoom to fit that shape so initial view makes sense
                resetZoom2DToShape(ilc->getBaseCrossSection());
                std::cout << "[COMMAND] Shape set as default (simulation not started)\n";
                return "OK: Reference shape set (default). Start will use this shape.\n";
            }

            // If simulation running -> perform smooth online morph WITHOUT shrinking:
            std::vector<Point2D> currentRef = ilc->getBaseCrossSection();

            // compute max radius of currentRef and newRef and scale newRef so its size matches currentRef
            auto maxRadius = [](const std::vector<Point2D>& s)->double {
                if (s.empty()) return 1.0;
                Point2D c = ShapeGenerator::computeCentroid(s);
                double mr = 0;
                for (auto &p: s) mr = std::max(mr, std::hypot(p.x - c.x, p.y - c.y));
                return mr;
            };
            double rCur = std::max(1e-8, maxRadius(currentRef));
            double rNew = std::max(1e-8, maxRadius(newRef));
            double scaleFactor = rCur / rNew;

            if (std::abs(scaleFactor - 1.0) > 1e-9) {
                Point2D cNew = ShapeGenerator::computeCentroid(newRef);
                for (auto &p : newRef) {
                    p.x = cNew.x + (p.x - cNew.x) * scaleFactor;
                    p.y = cNew.y + (p.y - cNew.y) * scaleFactor;
                }
            }

            // Visualize a short morph preview using the current reference (not last completed path)
            auto morphFrom = currentRef;
            auto morphRings = generateMorphRings(morphFrom, newRef, 12, 0.01);
            if (!rendererClient.isConnected()) rendererClient.connectToRenderer("127.0.0.1", RENDERER_PORT);
            rendererClient.sendPath3D(morphRings);
            writeGCodeForPath(flattenRingsToPath(morphRings), std::string("morph_transition.gcode"));

            // Start the ILC gradual morph (ILC will update reference over iterations)
            ilc->startMorphTo(newRef, 0.06);
            std::cout << "[COMMAND] Starting runtime morph to new shape\n";
            return "OK: Reference will morph to " + shapeType + " — ILC adapting online\n";
        }


        else if (action == "morph") {
            std::string shapeType;
            double progress = 0.5;
            iss >> shapeType >> progress;

            std::vector<Point2D> target;
            if (shapeType == "circle") target = ShapeGenerator::generateCircle(NUM_POINTS);
            else if (shapeType == "ellipse") target = ShapeGenerator::generateEllipse(NUM_POINTS);
            else if (shapeType == "square") target = ShapeGenerator::generateSquare(NUM_POINTS);
            else if (shapeType == "star") target = ShapeGenerator::generateStar(NUM_POINTS);
            else return "ERROR: Unknown morph shape\n";

            ilc->morphReferenceTo(target, progress);
            return "OK: Morphing reference toward " + shapeType + " (progress=" + std::to_string(progress) + ")\n";
        }

        else if (action == "dome") {
            // dome [<shape> [params...]]
            // If no shape specified -> collapse current reference to centroid (zero-dimension)
            std::string shapeType;
            if (!(iss >> shapeType)) {
                // no args -> collapse to centroid
                auto tgt = ilc->makeCollapsedTarget();
                ilc->startDomeToTarget(tgt);
                return "OK: Dome started (collapse to centroid) — ILC will adapt until convergence\n";
            }

            // shape provided: accept circle, ellipse, square, star with their usual params
            std::vector<Point2D> domeTarget;
            if (shapeType == "circle") {
                double radius = 1.0; iss >> radius;
                domeTarget = ShapeGenerator::generateCircle(NUM_POINTS, radius);
            } else if (shapeType == "ellipse") {
                double a = 1.2, b = 0.7; iss >> a >> b;
                domeTarget = ShapeGenerator::generateEllipse(NUM_POINTS, a, b);
            } else if (shapeType == "square") {
                double side = 1.6; iss >> side;
                domeTarget = ShapeGenerator::generateSquare(NUM_POINTS, side);
            } else if (shapeType == "star") {
                double outer = 1.0, inner = 0.4; iss >> outer >> inner;
                domeTarget = ShapeGenerator::generateStar(NUM_POINTS, outer, inner);
            } else {
                return "ERROR: Unknown dome shape\n";
            }

            ilc->startDomeToTarget(domeTarget);
            std::ostringstream resp;
            resp << "OK: Dome reference set to shape " << shapeType
                 << " with dims (";
            // print first few param echoes - rough
            resp << "…)";
            return resp.str() + " — ILC will adapt until convergence\n";
        }

        else if (action == "status") {
            std::ostringstream oss;
            oss << "Iteration: " << ilc->getIteration() << "\n";
            oss << "RMS Error: " << ilc->getRMSError() << "\n";
            oss << "Error Level: " << (ilc->getErrorLevel() * 100) << "%\n";
            oss << "Noise: " << (ilc->getNoiseEnabled() ? "ON" : "OFF") << "\n";
            oss << "Avg Correction: " << ilc->getAvgCorrection() << "\n";
            oss << "Running: " << (*isSimRunning ? "YES" : "NO") << "\n";
            return oss.str();
        }
        else if (action == "help") {
            return "Commands:\n"
                   "  start - Start simulation\n"
                   "  stop - Stop simulation\n"
                   "  reset - Reset ILC\n"
                   "  error <level> - Set error level (0.0-1.0)\n"
                   "  lr <rate> - Set learning rate (0.1-0.8)\n"
                   "  smooth <alpha> - Set smoothing factor (0.1-1.0)\n"
                   "  noise <on|off> - Enable/disable noise\n"
                   "  shape <type> [params] - Change shape (circle, ellipse, square, star)\n"
                   "  status - Get current status\n"
                   "  help - Show this help\n";
        }

        return "ERROR: Unknown command\n";
    }
};

// ============================================================================
// SPIRAL PATH GENERATOR
// ============================================================================
// Each "revolution" becomes one layer. z is layerIndex * layerHeight (not per-point incremental),
// so rings stack on top of each other instead of forming a long spiral/cylinder.
std::vector<std::vector<Point3D>> generateSpiralRingsFromCrossSection(
    const std::vector<Point2D>& crossSection,
    double layerHeight,
    int numLayers,
    bool makeDome = false)
{
    std::vector<std::vector<Point3D>> rings;
    if (crossSection.empty()) return rings;

    int N = (int)crossSection.size();

    for (int layer = 0; layer < numLayers; ++layer) {
        double t = (double)layer / std::max(1, numLayers - 1); // 0..1
        double scale = 1.0;
        if (makeDome) {
            double s = 1.0 - t;
            scale = s * s * (3 - 2 * s); // smoothstep(s)
        }
        std::vector<Point2D> scaled2d = ShapeGenerator::scaleShapeAroundCentroid(crossSection, scale);

        std::vector<Point3D> ring; ring.reserve(N);
        double z = layer * layerHeight; // <- important: entire ring at same z
        for (int i = 0; i < N; ++i) {
            double x = scaled2d[i].x;
            double y = scaled2d[i].y;
            ring.emplace_back(x, y, z);
        }
        rings.push_back(std::move(ring));
    }
    return rings;
}


// ============================================================================
// MORPH RING GENERATOR (for smooth transition between shapes)
// ============================================================================
std::vector<std::vector<Point3D>> generateMorphRings(
    const std::vector<Point2D>& fromRing, const std::vector<Point2D>& toRef,
    int revolutions, double heightPerRevolution)
{
    std::vector<std::vector<Point3D>> rings;
    int N = (int)std::min(fromRing.size(), toRef.size());
    for (int rev = 0; rev < revolutions; ++rev) {
        double progress = (double)rev / std::max(1, revolutions-1);
        double s = progress * progress * (3 - 2 * progress); // smoothstep
        std::vector<Point2D> interpolated; interpolated.reserve(N);
        for (int i = 0; i < N; ++i) {
            Point2D a = fromRing[i % fromRing.size()];
            Point2D b = toRef[i % toRef.size()];
            interpolated.emplace_back((1-s)*a.x + s*b.x, (1-s)*a.y + s*b.y);
        }
        std::vector<Point3D> ring;
        for (int i=0; i<N; ++i) {
            double z = (rev * N + i) * (heightPerRevolution / N);
            ring.emplace_back(interpolated[i].x, interpolated[i].y, z);
        }
        rings.push_back(std::move(ring));
    }
    return rings;
}

// ============================================================================
// MAIN SIMULATOR
// ============================================================================
int main() {
    std::cout << "=== ILC Real-Time Tracker ===" << std::endl;
    std::cout << "Initializing..." << std::endl;

    ILCController ilc(NUM_POINTS, 0.4);
    X11Visualizer viz;

    // Attempt to connect once at startup to external renderer
    rendererClient.connectToRenderer("127.0.0.1", RENDERER_PORT);

    std::atomic<bool> isRunning(false);
    std::mutex ilcMutex;

    CommandServer server(&ilc, &isRunning, &ilcMutex);
    server.start();

    std::cout << "\n[READY] Visualization window opened" << std::endl;
    std::cout << "[READY] Command server listening on port " << SERVER_PORT << std::endl;
    std::cout << "[READY] Use command client to control simulation" << std::endl;

    double time = 0;
    int pathIndex = 0;
    Point2D robotPos(1, 0);

    auto lastTime = std::chrono::steady_clock::now();
    // track dome active state so we can stop when dome converges
    bool prevDomeActive = ilc.isDomeActive();


    // Single combined G-code file opened in append mode
    static std::ofstream gcodeFile("ilc_path_combined.gcode", std::ios::app);
    if (!gcodeFile.is_open()) {
        std::cerr << "[GCODE] Warning: cannot open ilc_path_combined.gcode for append\n";
    }

    while (true) {
        auto currentTime = std::chrono::steady_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(currentTime - lastTime).count();

        if (elapsed >= 16) { // ~60 FPS
            lastTime = currentTime;

            {
                std::lock_guard<std::mutex> lock(ilcMutex);

                if (isRunning) {
                    time += 0.8;
                    pathIndex = (int)time % NUM_POINTS;
                    robotPos = ilc.getCurrentPosition(pathIndex);

                    // Check for iteration completion
                    if (pathIndex == 0 && time > NUM_POINTS &&
                        ilc.getCurrentTrajectory().size() >= (size_t)NUM_POINTS) {

                        ilc.completeIteration();
                        time = 0;

                        // After completing an iteration, if dome just finished (transitioned from active->inactive),
                        // stop the simulation automatically.
                        bool nowDomeActive = ilc.isDomeActive();
                        if (prevDomeActive && !nowDomeActive) {
                            isRunning = false;
                            std::cout << "[MAIN] Dome convergence complete -> simulation stopped\n";
                        }
                        prevDomeActive = nowDomeActive;
                    }

                    // Update the 3D view here so it syncs with new layers

                    // ----------------------- send observed/completed layers (throttled) -----------------------
                    // Build rings from ilc.completedPaths (observed) and currentTrajectory as top layer.
                    // Send only the *new* layers that haven't been sent yet to avoid spamming heavy data.
                    static size_t lastSentLayerCount = 0;
                    double layerHeight = 0.1;

                    auto completed = ilc.getCompletedPaths(); // vector<vector<Point2D>>
                    std::vector<std::vector<Point3D>> toSend;

                    // convert completed paths -> rings, set z = layerIndex * layerHeight
                    for (size_t li = 0; li < completed.size(); ++li) {
                        if (li < lastSentLayerCount) continue; // already sent this layer
                        std::vector<Point3D> ring;
                        ring.reserve(completed[li].size());
                        for (const auto &p : completed[li]) ring.emplace_back(p.x, p.y, (double)li * layerHeight);
                        toSend.push_back(std::move(ring));
                    }

                    // optionally send the current partial trajectory as top visualization (observed so far)
                    const auto& curTraj = ilc.getCurrentTrajectory();
                    if (!curTraj.empty()) {
                        std::vector<Point3D> curRing;
                        curRing.reserve(curTraj.size());
                        double zTop = (double)completed.size() * layerHeight;
                        for (const auto &p : curTraj) curRing.emplace_back(p.x, p.y, zTop);
                        toSend.push_back(std::move(curRing));
                    }


                    // copy of toSend is already local; release lock (we are inside lock already in your code snippet)
                    // so instead of calling sendPath3D under ilcMutex, spawn a thread:
                    if (!toSend.empty()) {
                        std::thread sender([toSend]() mutable {
                            // attempt to ensure connection before sending; rendererClient is thread-safe via its mutex
                            // keep a couple retries if disconnected
                            for (int attempt = 0; attempt < 2; ++attempt) {
                                if (rendererClient.isConnected() || rendererClient.connectToRenderer("127.0.0.1", RENDERER_PORT)) {
                                    rendererClient.sendPath3D(toSend);
                                    break;
                                }
                                std::this_thread::sleep_for(std::chrono::milliseconds(50));
                            }
                        });
                        sender.detach();

                        // update lastSentLayerCount only for fully completed layers (not for currentTrajectory)
                        lastSentLayerCount = completed.size();
                    }

                    // Write G-code only for newly completed layers (not current in-progress ring)
                    if (!completed.empty() && gcodeFile.is_open()) {
                        for (size_t li = lastSentLayerCount; li < completed.size(); ++li) {
                            std::vector<Point3D> layer3d;
                            layer3d.reserve(completed[li].size());
                            double z = li * layerHeight;
                            for (const auto &p : completed[li]) layer3d.emplace_back(p.x, p.y, z);
                            writeGCodeForPath(layer3d, gcodeFile);
                        }
                    }
                }
            }

            // 2D rendering

            // ----- poll X events for simple 2D zoom control (mouse wheel + keyboard) -----
            {
                Display* dpy = viz.getDisplay();
                while (XPending(dpy) > 0) {
                    XEvent ev;
                    XNextEvent(dpy, &ev);
                    if (ev.type == ButtonPress) {
                        XButtonEvent be = ev.xbutton;
                        // mouse wheel: button 4 = up, 5 = down
                        if (be.button == 4) {
                            // wheel up -> zoom in (factor >1)
                            applyZoom2D(1.15, &ilc.getBaseCrossSection());
                        } else if (be.button == 5) {
                            // wheel down -> zoom out
                            applyZoom2D(1.0/1.15, &ilc.getBaseCrossSection());
                        }
                    } else if (ev.type == KeyPress) {
                        KeySym ks = XLookupKeysym(&ev.xkey, 0);
                        if (ks == XK_plus || ks == XK_equal) {
                            applyZoom2D(1.15, &ilc.getBaseCrossSection());
                        } else if (ks == XK_minus || ks == XK_underscore) {
                            applyZoom2D(1.0/1.15, &ilc.getBaseCrossSection());
                        } else if (ks == XK_r || ks == XK_R) {
                            // reset 2D zoom/view to current reference
                            resetZoom2DToShape(ilc.getBaseCrossSection());
                        }
                    }
                    // ignore other events
                }
            }
            // ----- end X event polling -----

            // 2D rendering (throttled to ~30 FPS to avoid X11 flashing)
            static auto lastDraw = std::chrono::steady_clock::now();
            auto nowDraw = std::chrono::steady_clock::now();
            auto msSince = std::chrono::duration_cast<std::chrono::milliseconds>(nowDraw - lastDraw).count();
            if (msSince >= 33) { // ~30 FPS
                lastDraw = nowDraw;

                viz.clear();
                viz.drawGrid();

                {
                    std::lock_guard<std::mutex> lock(ilcMutex);

                    viz.drawPath(ilc.getReference(), 1, 3, true); // reference always blue (colorIdx 1)

                    const auto& completed = ilc.getCompletedPaths();
                    for (const auto& path : completed) {
                        int colorIdx = (ilc.getErrorLevel() > 0) ? 2 : 1;
                        viz.drawPath(path, colorIdx, 2, true);
                    }

                    if (ilc.getCurrentTrajectory().size() > 2) {
                        int colorIdx = (ilc.getErrorLevel() > 0) ? 2 : 1;
                        viz.drawPath(ilc.getCurrentTrajectory(), colorIdx, 3, false);
                    }

                    if (isRunning) {
                        int robotColor = (ilc.getErrorLevel() > 0) ? 2 : 1;
                        viz.drawRobot(robotPos, robotColor, 10);
                    }

                    std::ostringstream ss;
                    ss << "Iteration: " << ilc.getIteration()
                       << " | RMS Error: " << std::fixed << std::setprecision(4) << ilc.getRMSError()
                       << " | Error Level: " << (int)(ilc.getErrorLevel() * 100) << "%";
                    viz.drawText(20, 30, ss.str());
                }

                viz.flush();
            }
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
    return 0;
}
